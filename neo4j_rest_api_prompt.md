### Prompt for Generating Neo4j REST Services

**Objective:**

Create a complete RESTful API using Python and FastAPI to perform CRUD (Create, Read, Update, Delete) and bulk data operations on a Neo4j graph database. The API will manage two primary types of entities: **Nodes** and **Relations**.

**Data Models:**

The API should be built around the following data structures. All `id` fields must be service-layer generated UUIDs.

1.  **Node:**
    *   `id`: A string containing a UUID generated by the service before creation.
    *   `labels`: A list of strings representing the node's labels (e.g., `["Person", "User"]`).
    *   `properties`: A JSON object (dictionary) of key-value pairs representing the node's data (e.g., `{"name": "Alice", "age": 30}`).

2.  **Relation (or Relationship):**
    *   `id`: A string containing a UUID generated by the service before creation.
    *   `type`: A string describing the relationship type (e.g., "KNOWS", "WORKS_FOR").
    *   `startNode`: The unique `id` of the starting node.
    *   `endNode`: The unique `id` of the ending node.
    *   `properties`: A JSON object (dictionary) of key-value pairs representing the relationship's data (e.g., `{"since": "2022-01-15"}`).

**Technology Stack:**

*   **Framework:** FastAPI
*   **Database Driver:** The official `neo4j` Python driver.
*   **Server:** Uvicorn
*   **Data Validation:** Pydantic

  - Neo4j Connection Details
    - URI = "bolt://localhost:7687"
    - USERNAME = "neo4j"
    - PASSWORD = "kbi91717" # IMPORTANT: Change this in a production environment!

**API Endpoints Specification:**

---

#### 1. Node Endpoints

Base Path: `/nodes`

*   **Create a Node**
    *   **Endpoint:** `POST /nodes`
    *   **Action:** The service must generate a UUID for the `id`. This `id` is added to the `properties` dictionary.
    *   **Request Body:** A JSON object containing `labels` and `properties`.
    *   **Response Body:** The full Node object, including the generated `id`.
    *   **Cypher:** `CREATE (n:{labels} $properties) RETURN n` (where `$properties` includes the `id`).

*   **Get a Node by ID**
    *   **Endpoint:** `GET /nodes/{node_id}`
    *   **Response Body:** The requested Node object.
    *   **Cypher:** `MATCH (n {id: $node_id}) RETURN n`

*   **Update a Node by ID**
    *   **Endpoint:** `PUT /nodes/{node_id}`
    *   **Request Body:** A JSON object with optional `labels` and `properties` to update.
    *   **Response Body:** The updated Node object.
    *   **Cypher:** `MATCH (n {id: $node_id}) SET n += $properties RETURN n`

*   **Delete a Node by ID**
    *   **Endpoint:** `DELETE /nodes/{node_id}`
    *   **Action:** Deletes the node and any relationships connected to it.
    *   **Response Body:** A confirmation message.
    *   **Cypher:** `MATCH (n {id: $node_id}) DETACH DELETE n`

*   **List All Nodes**
    *   **Endpoint:** `GET /nodes`
    *   **Query Parameters:** `skip` (int, default 0), `limit` (int, default 10).
    *   **Response Body:** A list of Node objects.
    *   **Cypher:** `MATCH (n) RETURN n SKIP $skip LIMIT $limit`

---

#### 2. Relation Endpoints

Base Path: `/relations`

*   **Create a Relation**
    *   **Endpoint:** `POST /relations`
    *   **Action:** The service must generate a UUID for the `id`. This `id` is added to the `properties` dictionary.
    *   **Request Body:** A JSON object containing `startNode` (ID), `endNode` (ID), `type`, and `properties`.
    *   **Response Body:** The full Relation object.
    *   **Cypher:** `MATCH (a {id: $startNode}), (b {id: $endNode}) CREATE (a)-[r:{type} $properties]->(b) RETURN type(r) as type, r.id as id, r as properties, a.id as startNode, b.id as endNode`

*   **Get a Relation by ID**
    *   **Endpoint:** `GET /relations/{relation_id}`
    *   **Response Body:** The requested Relation object.
    *   **Cypher:** `MATCH (a)-[r {id: $relation_id}]->(b) RETURN type(r) as type, r.id as id, r as properties, a.id as startNode, b.id as endNode`

*   **Update a Relation by ID**
    *   **Endpoint:** `PUT /relations/{relation_id}`
    *   **Request Body:** A JSON object with `properties` to update.
    *   **Response Body:** The updated Relation object.
    *   **Cypher:** `MATCH ()-[r {id: $relation_id}]-() SET r += $properties RETURN r`

*   **Delete a Relation by ID**
    *   **Endpoint:** `DELETE /relations/{relation_id}`
    *   **Response Body:** A confirmation message.
    *   **Cypher:** `MATCH ()-[r {id: $relation_id}]-() DELETE r`

---

#### 3. Utility Endpoints

Base Path: `/utils`

*   **Export Data**
    *   **Endpoint:** `GET /utils/export`
    *   **Action:** Exports all nodes and relationships from the database.
    *   **Response Body:** A JSON object with two keys: `nodes` (a list of Node objects) and `relations` (a list of Relation objects).

*   **Import Data**
    *   **Endpoint:** `POST /utils/import`
    *   **Action:**
        1.  **Clear Database:** Deletes all existing nodes and relationships.
        2.  **Import from File:** Accepts a JSON file upload. The file should contain a JSON object with `nodes` and `relations` keys.
        3.  **Populate Database:** Creates all nodes and relationships from the file.
    *   **Request Body:** A JSON file upload (`UploadFile`).
    *   **Response Body:** A summary of the import (e.g., `{"nodes_created": 50, "relations_created": 100}`).

---

**Implementation Requirements:**

1.  **Project Structure:** Organize the code logically (e.g., `main.py`, `crud.py`, `models.py`, `database.py`).
2.  **Configuration:** Neo4j connection details should be configurable via environment variables.
3.  **Error Handling:** Implement robust error handling for database issues and invalid requests.
4.  **Dependencies:** Include a `requirements.txt` file (`fastapi`, `uvicorn`, `neo4j`, `pydantic`, `python-multipart`).
5.  **Documentation:** Use Pydantic models to ensure clear OpenAPI documentation.
6.  **Additional:** Support CORS


**dev instructions**
Localhost:8080/nodes

Kill the app
lsof -t -i:8000 | xargs kill -9 

 1 cd /Users/kepingbi/20250728/backend
   2 uvicorn app.main:app --reload